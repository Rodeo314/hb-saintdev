diff -Ncr hb-libav-orig/libavformat/avformat.h hb-libav-opt/libavformat/avformat.h
*** hb-libav-orig/libavformat/avformat.h	Sat Jul 28 23:29:46 2012
--- hb-libav-opt/libavformat/avformat.h	Fri Nov 23 09:54:19 2012
***************
*** 721,726 ****
--- 721,730 ----
          int64_t codec_info_duration;
          int nb_decoded_frames;
          int found_decoder;
+         int64_t fps_first_dts;
+         int     fps_first_dts_idx;
+         int64_t fps_last_dts;
+         int     fps_last_dts_idx;
      } *info;
  
      int pts_wrap_bits; /**< number of bits in pts (used for wrapping control) */
diff -Ncr hb-libav-orig/libavformat/utils.c hb-libav-opt/libavformat/utils.c
*** hb-libav-orig/libavformat/utils.c	Sat Jul 28 23:29:46 2012
--- hb-libav-opt/libavformat/utils.c	Fri Nov 23 09:58:45 2012
***************
*** 2252,2258 ****
      int orig_nb_streams = ic->nb_streams;        // new streams might appear, no options for those
  
      for(i=0;i<ic->nb_streams;i++) {
!         AVCodec *codec;
          AVDictionary *thread_opt = NULL;
          st = ic->streams[i];
  
--- 2252,2258 ----
      int orig_nb_streams = ic->nb_streams;        // new streams might appear, no options for those
  
      for(i=0;i<ic->nb_streams;i++) {
!         const AVCodec *codec;
          AVDictionary *thread_opt = NULL;
          st = ic->streams[i];
  
***************
*** 2287,2293 ****
--- 2287,2297 ----
      }
  
      for (i=0; i<ic->nb_streams; i++) {
+ #if FF_API_R_FRAME_RATE
          ic->streams[i]->info->last_dts = AV_NOPTS_VALUE;
+ #endif
+         ic->streams[i]->info->fps_first_dts = AV_NOPTS_VALUE;
+         ic->streams[i]->info->fps_last_dts  = AV_NOPTS_VALUE;
      }
  
      count = 0;
***************
*** 2314,2321 ****
              if (ic->fps_probe_size >= 0)
                  fps_analyze_framecount = ic->fps_probe_size;
              /* variable fps and no guess at the real fps */
!             if(   tb_unreliable(st->codec) && !(st->r_frame_rate.num && st->avg_frame_rate.num)
!                && st->info->duration_count < fps_analyze_framecount
                 && st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
                  break;
              if(st->parser && st->parser->parser->split && !st->codec->extradata)
--- 2318,2325 ----
              if (ic->fps_probe_size >= 0)
                  fps_analyze_framecount = ic->fps_probe_size;
              /* variable fps and no guess at the real fps */
!             if(   tb_unreliable(st->codec) && !st->avg_frame_rate.num
!                && st->codec_info_nb_frames < fps_analyze_framecount
                 && st->codec->codec_type == AVMEDIA_TYPE_VIDEO)
                  break;
              if(st->parser && st->parser->parser->split && !st->codec->extradata)
***************
*** 2383,2402 ****
              break;
          }
  
!         pkt= add_to_pktbuf(&ic->packet_buffer, &pkt1, &ic->packet_buffer_end);
          if ((ret = av_dup_packet(pkt)) < 0)
              goto find_stream_info_err;
  
          read_size += pkt->size;
  
          st = ic->streams[pkt->stream_index];
!         if (st->codec_info_nb_frames>1) {
!             if (av_rescale_q(st->info->codec_info_duration, st->time_base, AV_TIME_BASE_Q) >= ic->max_analyze_duration) {
                  av_log(ic, AV_LOG_WARNING, "max_analyze_duration reached\n");
                  break;
              }
-             st->info->codec_info_duration += pkt->duration;
          }
          {
              int64_t last = st->info->last_dts;
  
--- 2387,2444 ----
              break;
          }
  
!         if (ic->flags & 0x0040) {
!             pkt = &pkt1;
!         } else {
!             pkt = add_to_pktbuf(&ic->packet_buffer, &pkt1,
!                                 &ic->packet_buffer_end);
          if ((ret = av_dup_packet(pkt)) < 0)
              goto find_stream_info_err;
+         }
  
          read_size += pkt->size;
  
          st = ic->streams[pkt->stream_index];
!         if (pkt->dts != AV_NOPTS_VALUE && st->codec_info_nb_frames > 1) {
!             /* check for non-increasing dts */
!             if (st->info->fps_last_dts != AV_NOPTS_VALUE &&
!                 st->info->fps_last_dts >= pkt->dts) {
!                 av_log(ic, AV_LOG_WARNING, "Non-increasing DTS in stream %d: "
!                        "packet %d with DTS %"PRId64", packet %d with DTS "
!                        "%"PRId64"\n", st->index, st->info->fps_last_dts_idx,
!                        st->info->fps_last_dts, st->codec_info_nb_frames, pkt->dts);
!                 st->info->fps_first_dts = st->info->fps_last_dts = AV_NOPTS_VALUE;
!             }
!             /* check for a discontinuity in dts - if the difference in dts
!              * is more than 1000 times the average packet duration in the sequence,
!              * we treat it as a discontinuity */
!             if (st->info->fps_last_dts != AV_NOPTS_VALUE &&
!                 st->info->fps_last_dts_idx > st->info->fps_first_dts_idx &&
!                 (pkt->dts - st->info->fps_last_dts) / 1000 >
!                 (st->info->fps_last_dts - st->info->fps_first_dts) / (st->info->fps_last_dts_idx - st->info->fps_first_dts_idx)) {
!                 av_log(ic, AV_LOG_WARNING, "DTS discontinuity in stream %d: "
!                        "packet %d with DTS %"PRId64", packet %d with DTS "
!                        "%"PRId64"\n", st->index, st->info->fps_last_dts_idx,
!                        st->info->fps_last_dts, st->codec_info_nb_frames, pkt->dts);
!                 st->info->fps_first_dts = st->info->fps_last_dts = AV_NOPTS_VALUE;
!             }
! 
!             /* update stored dts values */
!             if (st->info->fps_first_dts == AV_NOPTS_VALUE) {
!                 st->info->fps_first_dts     = pkt->dts;
!                 st->info->fps_first_dts_idx = st->codec_info_nb_frames;
!             }
!             st->info->fps_last_dts = pkt->dts;
!             st->info->fps_last_dts_idx = st->codec_info_nb_frames;
! 
!             /* check max_analyze_duration */
!             if (av_rescale_q(pkt->dts - st->info->fps_first_dts, st->time_base,
!                              AV_TIME_BASE_Q) >= ic->max_analyze_duration) {
                  av_log(ic, AV_LOG_WARNING, "max_analyze_duration reached\n");
                  break;
              }
          }
+ #if FF_API_R_FRAME_RATE
          {
              int64_t last = st->info->last_dts;
  
***************
*** 2420,2425 ****
--- 2462,2468 ----
              if (last == AV_NOPTS_VALUE || st->info->duration_count <= 1)
                  st->info->last_dts = pkt->dts;
          }
+ #endif
          if(st->parser && st->parser->parser->split && !st->codec->extradata){
              int i= st->parser->parser->split(st->codec, pkt->data, pkt->size);
              if (i > 0 && i < FF_MAX_EXTRADATA_SIZE) {
***************
*** 2455,2464 ****
      for(i=0;i<ic->nb_streams;i++) {
          st = ic->streams[i];
          if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
!             if (st->codec_info_nb_frames>2 && !st->avg_frame_rate.num && st->info->codec_info_duration)
                  av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,
!                           (st->codec_info_nb_frames-2)*(int64_t)st->time_base.den,
!                           st->info->codec_info_duration*(int64_t)st->time_base.num, 60000);
              // the check for tb_unreliable() is not completely correct, since this is not about handling
              // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g.
              // ipmovie.c produces.
--- 2498,2528 ----
      for(i=0;i<ic->nb_streams;i++) {
          st = ic->streams[i];
          if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {
!             if (!st->avg_frame_rate.num && st->info->fps_last_dts != st->info->fps_first_dts) {
!                 int64_t delta_dts = st->info->fps_last_dts - st->info->fps_first_dts;
!                 int delta_packets = st->info->fps_last_dts_idx - st->info->fps_first_dts_idx;
!                 int      best_fps = 0;
!                 double best_error = 0.01;
                  av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,
!                           delta_packets*(int64_t)st->time_base.den,
!                           delta_dts*(int64_t)st->time_base.num, 60000);
! 
!                 /* round guessed framerate to a "standard" framerate if it's
!                  * within 1% of the original estimate*/
!                 for (j = 1; j < MAX_STD_TIMEBASES; j++) {
!                     AVRational std_fps = { get_std_framerate(j), 12*1001 };
!                     double error = fabs(av_q2d(st->avg_frame_rate) / av_q2d(std_fps) - 1);
!                     if (error < best_error) {
!                         best_error = error;
!                         best_fps   = std_fps.num;
!                     }
!                 }
!                 if (best_fps) {
!                     av_reduce(&st->avg_frame_rate.num, &st->avg_frame_rate.den,
!                               best_fps, 12*1001, INT_MAX);
!                 }
!             }
! #if FF_API_R_FRAME_RATE
              // the check for tb_unreliable() is not completely correct, since this is not about handling
              // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g.
              // ipmovie.c produces.
***************
*** 2481,2486 ****
--- 2545,2551 ----
                  if (num && (!st->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(st->r_frame_rate)))
                      av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num, 12*1001, INT_MAX);
              }
+ #endif
          }else if(st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {
              if(!st->codec->bits_per_coded_sample)
                  st->codec->bits_per_coded_sample= av_get_bits_per_sample(st->codec->codec_id);
